ALTERNATE LED BLINKING.         
#include <reg51.h>
void delay(void);
void main(void)
{
    while(1)
    {
        P1 = 0xAA;   // 10101010 — alternate LEDs ON
        delay();

        P1 = 0x55;   // 01010101 — opposite pattern
        delay();
    }
}

void delay(void)
{
    TMOD = 0x01;
    TH0 = 0xFF;
    TL0 = 0x0A;
    TR0 = 1;
    while (TF0 == 0);
    TR0 = 0;
    TF0 = 0;
}











SINGLE LED MOVING:

#include <reg51.h>
void delay(void);
void main(void)
{
    unsigned char pattern;
    int i;

    while(1)
    {
        // Move LED from P1.0 to P1.7
        for(pattern = 0x01; pattern != 0x00; pattern <<= 1)
        {
            P1 = pattern;
            delay();
        }

        // Move LED back from P1.6 to P1.0
        for(pattern = 0x40; pattern != 0x00; pattern >>= 1)
        {
            P1 = pattern;
            delay();
        }
    }
}

void delay(void)
{
    unsigned int i, j;
    for(i = 0; i < 2000; i++)
        for(j = 0; j < 1275; j++); // ~2 sec delay for 12MHz crystal
}







7 SEGMENT DISPLAY :


#include <reg51.h>

unsigned char numbers[10] = {0x3F, 0x06, 0x5B, 0x4F, 
                             0x66, 0x6D, 0x7D, 0x07, 
                             0x7F, 0x6F};  // Hex codes for 0-9

void delay(unsigned int);

void main(void)
{
    unsigned char i;
    while(1)
    {
        for(i = 0; i < 10; i++)  // Display 0-9
        {
            P1 = numbers[i];
            delay(1000); // 1 sec delay
        }
    }
}

void delay(unsigned int time)
{
    unsigned int i, j;
    for(i=0; i<time; i++)
        for(j=0; j<1275; j++);
}





STEPPER MOTOR :

#include <reg51.h>

unsigned char array[4] = {0x08, 0x04, 0x02, 0x01}; // Step sequence

void delay_() {
    TMOD = 0x01;      // Timer 0, mode 1 (16-bit)
    TH0 = 0xFC;       // Load high byte
    TL0 = 0x66;       // Load low byte (~10ms, adjust for speed)
    TR0 = 1;           // Start timer
    while(TF0 == 0);   // Wait for timer overflow
    TR0 = 0;           // Stop timer
    TF0 = 0;           // Clear overflow flag
}

void main() {
    int i;
    while(1) {
        for(i = 0; i < 4; i++) {
            P2 = array[i]; // Send step pattern to Port 2
            delay_();       // Wait before next step
        }
    }
}





#include<reg51.h>
5A. (LCD DISPLAY WITH 8051)


#include<reg51.h>
sbit rs=P2^2;
sbit rw=  P2^1;
sbit en= P2^0;                                      
void DelayMs(delay)
{
    int i,j;
    for(i=0;i<delay;i++)
    {
     for(j=0;j<100;j++);
    }
 
}
void write_lcd_data(value)
{
    P1=value;
    DelayMs(250);
    rs=1;
    rw=0;
    en=1;
    DelayMs(10);
    en=0;
}
  void write_lcd_command(value)
{
    P1=value;
    DelayMs(250);
    rs=0;
    rw=0;
    en=1;
    DelayMs(10);
    en=0;
}
void main(void)
{
    P1=0x00;
    P2=0x00;
    write_lcd_command(0x38);		// function set
    write_lcd_command(0x08);	 	// display off
    write_lcd_command(0x01);		//display clear
    write_lcd_command(0x06);		//entry mode set
    //write_lcd_command(0x08);
    //write_lcd_command(0x0C);
    write_lcd_command(0x0F);    	  // display on
  
    write_lcd_command(0x81);		 // set address counter value
    write_lcd_data('8');
    write_lcd_data('0');
    write_lcd_data('5');
    write_lcd_data('1');
    write_lcd_data('+');
    write_lcd_data('L');
    write_lcd_data('C');
    write_lcd_data('D');
    
    write_lcd_command(0xc0);//set address countervalue
    write_lcd_data('E');
    write_lcd_data('&');
    write_lcd_data('T');
    write_lcd_data('C');
    write_lcd_data('d');
    write_lcd_data('e');
    write_lcd_data('p');
    write_lcd_data('t');
 
        // DelayMs(250);
		while(1)
		{
 
		}
}
 


5B. ( LCD DISPLAY WITH PIC18)

#include <p18f4550.h>
 
#define LCD_EN LATAbits.LA1
#define LCD_RS LATAbits.LA0
#define LCDPORT LATB
 
void lcd_delay(unsigned int time)
{
 unsigned int i, j ;
 
    for(i=0;i<time;i++)
    {
            for(j=0;j<100;j++);
    }
}
void SendInstruction(unsigned char command)
{
     LCD_RS =0;// RS low : Instruction
     LCDPORT = command;
     LCD_EN =1;// EN High
     lcd_delay(10);
     LCD_EN =0;// EN Low; command sampled at EN falling edge
     lcd_delay(10);
}
void SendData(unsigned char lcddata)
{
     LCD_RS =1;// RS HIGH : DATA
     LCDPORT =lcddata;
     LCD_EN =1;// EN High
     lcd_delay(10);
     LCD_EN =0;// EN Low; data sampled at EN falling edge
     lcd_delay(10);
}
 
unsigned char*String1 ="SUDHANSHU JADHAV";
unsigned char*String2 ="ENTC dept";
 
void main(void)
{
    ADCON1 =0x0F;
    TRISB =0x00;       //set data port as output
    TRISAbits.RA0=0;  //RS pin
    TRISAbits.RA1=0;  // EN pin
    // TRISAbits.RA2 = 0;
    SendInstruction(0x38);      //8 bit mode, 2 line,5x7 dots
    SendInstruction(0x06);      // entry mode
    SendInstruction(0x0C);      //Display ON cursor OFF
    SendInstruction(0x01);      //Clear display
 
 SendInstruction(0x80);      //set address to 1st line
 while(*String1)
 {
  SendData(*String1);
  String1++;
 }
 SendInstruction(0xC0);      //set address to 2nd line
 while(*String2)
 {
  SendData(*String2);
  String2++;
 }
 while(1);
 
}








6.LED,RELAY,BUZZER

#include<P18F4550.h>
void delay()
{
	unsigned int i;
	for(i=0;i<30000;i++);
}
void main()
{
    unsigned char i, key = 0;
    TRISB = 0x00;                           //LED pins as output
    //LATB = 0x00;
    ADCON1 = 0x0F;                          //set pins as Digital
    TRISAbits.TRISA2 = 1;                   //set RA2 as input
    TRISAbits.TRISA3 = 1;                   //set RA3 as input
 
    TRISAbits.TRISA5 = 0;                   //set buzzer pin RA5 as output
    TRISAbits.TRISA4 = 0;                   //set relay pin RA4 as output
    while(1)
    {
        //LATAbits.LA2 = 1;
        //LATAbits.LA3 = 1;
 
        if(PORTAbits.RA2 == 0) key =0;      //If button1 pressed
        if(PORTAbits.RA3 == 0) key =1;      //If button2 pressed
 
        if(key == 0)
        {
            PORTAbits.RA4 = 1;             //Relay OFF
            PORTAbits.RA5 = 0;             //Buzzer OFF
            for(i=0;i<8;i++)                //Chase LED right to left
            {
                PORTB = 1<<i;
                delay();
                PORTB = 0x00;
                delay();
            }
        }
        if(key == 1)
        {
            PORTAbits.RA4 = 0;             //Relay ON
            PORTAbits.RA5 = 1;             //Buzzer ON
            for(i=7;i> 0;i--)               //Chase LED left to right
            {
                PORTB = 1<<i;
                delay();
                PORTB = 0x00;
                delay();
            }
        }
    }
}























EXP7. GENERATION OF SQUARE WAVE

#include <reg51.h>

sbit square_wave = P1^0;  // Output pin

void timer0_ISR(void) interrupt 1  // Timer0 interrupt vector
{
    TH0 = 0xEC;  // Reload high byte
    TL0 = 0x18;  // Reload low byte
    square_wave = ~square_wave;  // Toggle output
}

void main(void)
{
    TMOD = 0x01;  // Timer0, mode 1 (16-bit)
    TH0 = 0xEC;   // Initial preload
    TL0 = 0x18;

    EA = 1;   // Enable global interrupts
    ET0 = 1;  // Enable Timer0 interrupt
    TR0 = 1;  // Start Timer0

    while(1) {
        // Main loop can perform other tasks
    }
}













EXP10. LED INTERFACING (PROTEUS)

#include <reg51.h>
#include <stdio.h>
sbit pin0=P1^0;
sbit pin1=P1^1;
sbit pin2=P1^2;
sbit pin3=P1^3;
sbit pin4=P1^4;
sbit pin5=P1^5;
sbit pin6=P1^6;
sbit pin7=P1^7;
void delay(int value)
{
	int i,j;
	for (i=0;i<=value;i++)
		for (j=0;j<=5;j++);
}	
void main(void)
 {
	 while(1)
	 {
		 //for led 01
		 pin0=1;
		 pin1=0;
		 pin2=0;
		 pin3=0;
		 pin4=0;
		 pin5=0;
		 pin6=0;
		 pin7=0;
		 delay(4000);
		 pin0=0;
		 delay(4000);
		 //for led 02
		 pin0=0;
		 pin1=1;
		 pin2=0;
		 pin3=0;
		 pin4=0;
		 
                        pin5=0;
		 pin6=0;
		 pin7=0;                                  
		 delay(4000);
		 pin1=0;
		 delay(4000);
		 //for led 03
		 pin0=0;
		 pin1=0;
		 pin2=1;
		 pin3=0;
		 pin4=0;
		 pin5=0;
		 pin6=0;
		 pin7=0;
		 delay(4000);
		 pin2=0;
		 delay(4000);
		 //for led 04
		  pin0=0;
		 pin1=0;
		 pin2=0;
		 pin3=1;
		 pin4=0;
		 pin5=0;
		 pin6=0;
		 pin7=0;
		 delay(4000);
		 pin3=0;
		 delay(4000);
		 //for led 05
		  pin0=0;
		 pin1=0;
		 pin2=0;
		 pin3=0;
		 pin4=1;
		 pin5=0;
		 pin6=0;
		 pin7=0;
		 delay(4000);
		 pin4=0;
		 delay(4000);
		 //for led 06
		  pin0=0;
		 pin1=0;
		 pin2=0;
		 pin3=0;
		 pin4=0;
		 pin5=1;
		 pin6=0;
		 pin7=0;
		 delay(4000);
		 pin5=0;
		 delay(4000);
		 //for led 07
		  pin0=0;
		 pin1=0;
		 pin2=0;
		 pin3=0;
		 pin4=0;
		 pin5=0;
		 pin6=1;
		 pin7=0;
		 delay(4000);
		 pin6=0;
		 delay(4000);
		 //for led 08
		  pin0=0;
		 pin1=0;
		 pin2=0;
		 pin3=0;
		 pin4=0;
		 pin5=0;
		 pin6=0;
		 pin7=1;
		 delay(4000);
		 pin7=0;
		 delay(4000);
	 
